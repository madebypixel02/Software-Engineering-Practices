---
title: "PRAC 2"
subtitle: "Software Engineering"
author: Alejandro Pérez Bueno
date: today
date-format: "MMM DD, YYYY"
toc: true
toc-title: "Table of Contents"
linkcolor: blue
documentclass: report
link-citations: true
link-bibliography: true
filters:
  - diagram
format:
  gfm: default
  pdf:
    default-image-extension: svg
    linestretch: 1.25
    code-overflow: wrap
    keep-tex: true
    geometry:
      - top=30mm
      - left=20mm
      - heightrounded
    include-in-header:
      text: |
        \usepackage{fancyhdr}
          \pagestyle{fancy}
          \fancyhead[C]{UOC}
          \fancyhead[R]{aperez-b@uoc.edu}
          \fancyfoot{}
          \fancyfoot[C]{\thepage}
        \usepackage{fvextra}
        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
        \DefineVerbatimEnvironment{OutputCode}{Verbatim}{breaklines,commandchars=\\\{\}}
---

{{< pagebreak >}}

## Self-Responsibility Declaration

> I certify that I have carried out Practice 2 completely individually and only with the help that the
teaching staff of this subject considers appropriate, according to the instructions explained in the
“Originality in the evaluation” section of the classroom. I understand that non-original work and/or the
use of generative AI will mean that the submitted activity will not be corrected and will automatically
be assigned a grade of 0.

{{< pagebreak >}}

## Question 1

Here is a Swimlane activity diagram based on the success and alternate scenarios.

```{.plantuml}
@startuml
|Platform|
start
:Collect data from underwater sensors;
:Process data and identify an anomaly;
:Generate environmental alert and suggested actions;

|Biologist|
while (New Hypothesis?) is (yes)
  :Enter new params or update variables;
  |Platform|
  :Recalculate analysis;
endwhile (no)
  |Biologist|
  :Review alert and suggested actions;
fork
  |Biologist|
  if (Modify actions?) then (yes)
    :Document alternative action;
    |Platform|
    :Save choice for algorithm retraining;
  else (no)
  end if
fork again
  |Biologist|
  if (Dismiss Alert?) then (yes)
    |Biologist|
    :Mark alert as irrelevant or false positive;
    |Platform|
    :Archive alert and update incident;
  else (no)
  end if
|Biologist|
end fork
stop
@enduml
```

## Question 2

### Use cases

Old ones:

1. As a port technician, I want to consult reports to know the status of marine space indicators.
2. As a marine biologist, I want to monitor the marine environment to detect changes in the
ecosystem and adjust regeneration strategies to ensure its health.
3. As public administration staff, I want to visualize on a map the effectiveness of interventions
in various ports to efficiently allocate available funds.
4. As a communications technician, I want to download infographics to clearly show citizens the
improvement in biodiversity.

New ones:

5. As a port technician, I want to register maintenance incidents for marine sensors.
6. As a marine biologist, I want to compare current water quality data with historical data.
7. As public administration Staff, I want to approve budget allocations for specific port interventions.
8. As a communications technician, I want to publish an annual biodiversity newsletter for the public web portal.

### Use case diagram

```{.plantuml}
@startuml
left to right direction
actor "Port Technician" as PT
actor "Marine Biologist" as MB
actor "Public Administration Staff" as PA
actor "Communications Technician" as CT
rectangle "Marine Management System" {
    usecase "Consult reports" as UC1
    usecase "Monitor marine environment" as UC2
    usecase "Visualize effectiveness map" as UC3
    usecase "Download infographics" as UC4
    
    usecase "Register maintenance incidents" as UC1_New
    usecase "Compare water quality data" as UC2_New
    usecase "Approve budget allocations" as UC3_New
    usecase "Publish biodiversity newsletter" as UC4_New
}
PT --> UC1
PT --> UC1_New
MB --> UC2
MB --> UC2_New
PA --> UC3
PA --> UC3_New
CT --> UC4
CT --> UC4_New
@enduml
```

## Question 3

### Class diagram

```{.plantuml}
@startuml

' 1. Define Classes and Attributes
' Syntax for classes: class ClassName { attributes } [2]
class Sensor {
    id: String
    model: String
    xPosition: Real
    yPosition: Real
}

' Syntax for abstract class: abstract class ClassName [2]
abstract class Record {
    key: String
    value: Real
}

' Inheritance syntax: SuperClass <|-- SubClass [2]
class PhysicalRecord {
    unit: String
}

class BiologicalRecord {
    entity: String
}

class Algorithm {
    name: String
}

class Alert {
    description: String
    dateGenerated: Date
}

' Syntax for enumeration: enum EnumName [2]
enum DismissalReason {
    NotRelevant
    FalsePositive
}

class Action {
    actionID: String
    description: String
}

class Biologist {
    name: String
    employeeID: String
    email: String
    /alertsManaged: Integer
}

' Association Class for the selection logic [2]
class Selection {
    selectionDate: Date
    reason: String
}

' 2. Define Relationships

' Inheritance
Record <|-- PhysicalRecord
Record <|-- BiologicalRecord

Sensor "1" -- "*" Record : collects

' Association: Record to Algorithm
Record "*" -- "*" Algorithm : Processed by

' Association: Algorithm to Alert (Algorithm generates Alert)
Algorithm "1" -- "0..*" Alert : generates

' Association: Biologist to Alert (Manages)
Biologist "1" -- "*" Alert : manages

' Association: Alert to DismissalReason (Optional)
Alert --> "0..1" DismissalReason : dismissed reason

' Association: Alert to Action (Proposed actions)
Alert "1" -- "*" Action : proposes

' Association: Biologist to Action (Biologist proposes own action)
Biologist "0..1" -- "*" Action : proposes manual

' Association Class Link
' Syntax: (Class1, Class2) .. AssociationClass [2]
(Biologist, Action) .. Selection : selects

@enduml
```

### Keys, constraints and derived information

#### Keys of the domain classes

These attributes act as  unique identifiers for each class:

*   **Sensor:** `id`
*   **Action:** `actionID`
*   **Biologist:** `employeeID`
*   **Algorithm:** `name`: Since the system will store the name to identify the algorithm that processes data, it functions as the unique key here.

#### Integrity Constraints

*   **Record Specialization:** Every `Record` has to be specifically a `PhysicalRecord` or `BiologicalRecord`. No plain generic records allowed, so `Record` works as an abstract class.
*   **Dismissal Reason Validity:** The `dismissalReason` is limited to just "not relevant" or "false positive" which may be expressed as an enumeration.
*   **Dismissal Logic:** You only store a `dismissalReason` when the alert is actually dismissed.
*   **Alert Management:** Each `Alert` gets handled by just one `Biologist`, as the description notes that an alert is managed only by a single biologist.
*   **Action Origin:** An `Action` comes from either an `Algorithm` or a `Biologist`, but never from both at the same time (this is a case of an exclusive OR).

#### Derived Information

*   **Biologist: `/alertsManaged`**: You can get this by simply counting how many `Alert` instances are linked to the `Biologist` via the "manages" relationship right now.

## Question 4

### Class Diagram

```{.plantuml}
@startuml

'--- Style Configurations ---
skinparam classAttributeIconSize 0
skinparam linetype ortho

'--- Enumerations ---
enum Specialty {
  EnvironmentalImpactAssessor
  AirQualitySpecialist
  WaterQualitySpecialist
}

'--- Abstract Classes ---
abstract class AlertState {
  stateDate: Date
}

abstract class User {
  name: String
  employeeID: String
  email: String
}

'--- Classes ---
class Alert {
  description: String
  dateGenerated: Date
  dismissalReason: DismissalReason [0..1]
}

class NewAlert {
}

class InProgressAlert {
  isCritical: Boolean
}

class ResolvedAlert {
  resolutionDate: Date
  /duration: Duration
}

class Biologist {
  /alertsManaged: Integer
}

class EnvironmentalTechnician {
  yearsExperience: Integer
  specialties: Specialty [1..3]
}

class Report {
  reportID: String
  creationDate: Date
  /numberOfAlerts: Integer
}

'--- Inheritance Relationships ---
' Using <|-- for generalization [2]

AlertState <|-- NewAlert
AlertState <|-- InProgressAlert
AlertState <|-- ResolvedAlert

User <|-- Biologist
User <|-- EnvironmentalTechnician

'--- Associations and Compositions ---

' Composition: Alert has a history of AlertStates [2]
' Using *-- for composition
Alert "1" *-- "1..* {ordered}" AlertState : has history

' Association: Biologist manages InProgress alerts
InProgressAlert "0..*" -- "1" Biologist : assigned to

' Association: Technician reviews Resolved alerts
ResolvedAlert "0..*" -- "1" EnvironmentalTechnician : reviewed by

' Association: Technician generates Report
EnvironmentalTechnician "1" -- "*" Report : generates

' Association: Report includes Resolved alerts
' Note: Requirements say report includes "resolved alerts". 
' Modeling this as a relation to the Resolved state captures the resolution data accurately.
Report "*" -- "*" ResolvedAlert : includes

' Association: User reads Report (Auditing)
User "*" -- "*" Report : reads/accesses

@enduml
```

### Keys, constraints and derived information

#### Keys of the domain classes

These attributes act as unique identifiers for their class:

*   **Sensor:** `id`
*   **Action:** `actionID`
*   **Report:** `reportID`
*   **User (Biologist / EnvironmentalTechnician):** `employeeID`
*   **Algorithm:** `name`: since algorithms are named uniquely in the system.
*   **Record:** `Sensor.id` + `timestamp` + `key`. It's not one single field, but the combination of all three do make it unique.

#### Integrity Constraints

*   **State Transitions:** Alerts have to go through states in order from `New` to `InProgress` to `Resolved`.
*   **InProgress Assignment:** Once it's `InProgress`, it has to be handed off to a `Biologist`.
*   **Resolution Review:** For `Resolved` alerts, they need a check from an `EnvironmentalTechnician` before closing.
*   **Report Content:** Reports can only pull in alerts that are already `Resolved`.
*   **Technician Specialties:** Each `EnvironmentalTechnician` needs 1 to 3 specialties (thus the [1..3] in the diagram).
*   **Dismissal Status:** If there's a `dismissalReason`, the alert isn't active anymore
*   **User Uniqueness:** We can't have two users with the same `employeeID` or `email`

#### Derived Information

*   **Biologist: `/alertsManaged`**: we can count the `InProgressAlert` assigned to that Biologist at a given time.
*   **ResolvedAlert: `/duration`**: we can subtract the `dateGenerated` from the `resolutionDate` to get how long it took.
*   **Report: `/numberOfAlerts`**: we can count the `ResolvedAlert` connected to the report through the "includes" link.

## Question 5

### Class Diagram

```{.plantuml}
@startuml

' --- Styling and Configuration ---
skinparam classAttributeIconSize 0
skinparam linetype ortho
hide circle

' --- Enumerations ---
enum ServiceType {
  Transportation
  PrivateUse
  Fishing
  ContainerTransport
}

' --- Classes ---

class LocalMap {
  regionName: String
}

class Location {
  name: String
  postalCode: String
  xPosition: Real
  yPosition: Real
}

class Port {
  name: String
  capacity: Integer
  depth: Real
  numberOfDocks: Integer
  services: ServiceType [1..*]
}

class Intervention {
  interventionID: String
  description: String
}

class EnvironmentalTechnician {
  ' Attributes hidden as per instructions
}

class Evaluation {
  impactScore: Integer
}

' --- Relationships ---

' Composition: LocalMap consists of Locations [1]
LocalMap *-- "1..*" Location : consists of

' Association: Location to Port [1]
Location "1" -- "1..*" Port : located in

' Association: Port to Intervention (Performed) with Association Class
Port "*" -- "*" Intervention : /candidateInterventions
(Port, Intervention) .. Evaluation

' Association: Evaluation to Technician
Evaluation "*" -- "1" EnvironmentalTechnician : performed by
@enduml
```

::: {.callout-note}
The Classes from previous exercies are ommited because they remain the same. They all stem from the `EnvironmentalTechnician`
:::

### Keys, constraints and derived information

#### Keys of the domain classes

*   **Location:** postalCode
*   **Intervention:** interventionID
*   **LocalMap:** regionName
*   **Port:** name (assuming port names are unique within a location/map context, though `name` is the standard identifier provided)

#### Integrity Constraints

*   **Location:** `postalCode` must be unique.
*   **Port:** `services` must contain at least one value (`[1..*]`).
*   **Evaluation:** `impactScore` must be an integer between 1 and 10.
*   **EnvironmentalTechnician:** A single technician performs the evaluation.

#### Derived Information

*   **Port: `/candidateInterventions`**: Represents interventions calculated by the system based on the impact of interventions in ports with similar characteristics, rather than executed interventions.
